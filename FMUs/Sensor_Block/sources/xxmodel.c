/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  src\xxmodel.c
 *  model: 20-sim_Sensor
 *  expmt: 20-sim_Sensor
 *  date:  April 3, 2017
 *  time:  11:19:58 AM
 *  user:  INTO-CPS
 *  from:  20-sim 4.6 Professional Single
 *  build: 4.6.3.7711
 **********************************************************/

/* This file contains the actual model variables and equations */

/* Note: Alias variables are the result of full optimization
   of the model in 20-sim. As a result, only the real variables
   are used in the model for speed. The user may also include
   the alias variables by adding them to the end of the array:

   XXDouble xx_variables[NUMBER_VARIABLES + NUMBER_ALIAS_VARIABLES + 1];
   XXCharacter *xx_variable_names[] = {
     VARIABLE_NAMES, ALIAS_VARIABLE_NAMES, NULL
   };

   and calculate them directly after the output equations:

   void XXCalculateOutput (void)
   {
     OUTPUT_EQUATIONS
     ALIAS_EQUATIONS
   }
*/

/* system include files */
#include <stdlib.h>
#include <math.h>

/* 20-sim include files */
#include "xxmodel.h"
#include "xxfuncs.h"
#include "xxmatrix.h"
#include "xxTable2D.h"

/* The path to the extracted resource folder location provided by the
 * co-simulation engine for the currently active FMU instance
 */
const char* g_fmuResourceLocation = NULL;

#if (21 > 8192) && defined _MSC_VER
#pragma optimize("", off)
#endif
/* this method is called before calculation is possible */
void XXModelInitialize (xx_ModelInstance* model_instance)
{
	/* set the constants */
	xx_C[0] = XXString2Double ("Table2D.dll");		/* map\dll_name */
	xx_C[1] = XXString2Double ("Table2DInit");		/* map\initialize_function_name */
	xx_C[2] = XXString2Double ("TableRead");		/* map\function_name */


	/* set the parameters */
	xx_P[0] = -0.1;		/* lf_position_x */
	xx_P[1] = -0.1;		/* lf_position_y */
	xx_P[2] = 0.0;		/* lf_fail_time */
	xx_P[3] = 0.0;		/* ambient_light {W} */
	xx_P[4] = 0.0;		/* noise_level */
	xx_P[5] = 1.0;		/* id_1\C */
	xx_P[6] = 8.0;		/* lf_1\AD_8bit\bits */
	xx_P[7] = 0.0;		/* lf_1\AD_8bit\minimum */
	xx_P[8] = 255.0;		/* lf_1\AD_8bit\maximum */
	xx_P[9] = 5.0;		/* lf_1\ambient_light\led_power {W} */
	xx_P[10] = 0.5;		/* lf_1\ambient_light\rx_power_off {W} */
	xx_P[11] = 4.5;		/* lf_1\ambient_light\rx_power_on {W} */
	xx_P[12] = 255.0;		/* lf_1\percentageTo8BitValue\K */
	xx_P[13] = -1.6777216e7;		/* lf_1\raw_to_reflectivity\lo_input */
	xx_P[14] = -1.0;		/* lf_1\raw_to_reflectivity\hi_input */
	xx_P[15] = 0.1;		/* lf_1\raw_to_reflectivity\lo_output */
	xx_P[16] = 0.9;		/* lf_1\raw_to_reflectivity\hi_output */
	xx_P[17] = 223.0;		/* lf_1\response_delay\Gain\sensor_response_factor */
	xx_P[18] = XXString2Double ("map.txt");		/* map\path_follow_file_name */
	xx_P[19] = 3.0;		/* map\sample_matrix_size */
	xx_P[20] = 0.001;		/* map\sample_matrix_scale */


	/* set the initial values */
	xx_I[0] = 0.0;		/* lf_1\response_delay\Integrate\initial */


	/* set the states */
	xx_s[0] = xx_I[0];		/* lf_1\response_delay\Integrate\output */


	/* set the matrices */
	xx_M[0].mat = &xx_V[12];		/* lf_1\calculate_sensor_position\sensor_position */
	xx_M[0].rows = 2;
	xx_M[0].columns = 1;
	xx_M[1].mat = &xx_V[23];		/* map\input1 */
	xx_M[1].rows = 3;
	xx_M[1].columns = 1;
	xx_M[2].mat = &xx_V[26];		/* map\sample_offsets */
	xx_M[2].rows = 3;
	xx_M[2].columns = 1;
	xx_M[3].mat = &xx_V[30];		/* map\sample_matrix1 */
	xx_M[3].rows = 3;
	xx_M[3].columns = 3;
	xx_M[4].mat = &xx_V[47];		/* Mux\output */
	xx_M[4].rows = 4;
	xx_M[4].columns = 1;
	xx_M[5].mat = &xx_U[0];		/* xx_U1 */
	xx_M[5].rows = 1;
	xx_M[5].columns = 1;


}
#if (21 > 8192) && defined _MSC_VER
#pragma optimize("", on)
#endif

/* This function calculates the initial equations of the model.
 * These equations are calculated before anything else
 */
void XXCalculateInitial (xx_ModelInstance* model_instance)
{
	/* Make sure that the Table2D initialization function can find the resource
	 * location for this FMU instance
	 */
	g_fmuResourceLocation = model_instance->resourceLocation;

	Table2D_Initialize ();
		/* lf_1\AD_8bit\output = 255; */
		xx_V[3] = 255.0;

		/* map\retval = 0; */
		xx_V[42] = 0.0;

		/* map\id = dll (map\dll_name, map\initialize_function_name, map\path_follow_file_name); */
		Table2D_Table2DInit (&xx_P[18], 1, &xx_V[22], 1, xx_major);

		/* for map\i = 0 to map\sample_matrix_size - 1 */
		for (xx_V[29] = 0.0; xx_V[29] <= xx_P[19] - 1.0; xx_V[29]++)
		{
			/* map\sample_offsets[map\i + 1] = (map\i - ((map\sample_matrix_size - 1) / 2)) * map\sample_matrix_scale; */
			xx_M[2].mat[(XXInteger) (xx_V[29] + 1.0) - 1] = (xx_V[29] - ((xx_P[19] - 1.0) / 2.0)) * xx_P[20];
		}

		/* map\sensor_field_width = map\sample_matrix_size * map\sample_matrix_scale; */
		xx_V[41] = xx_P[19] * xx_P[20];

}

/* This function calculates the static equations of the model.
 * These equations are only dependent from parameters and constants
 */
void XXCalculateStatic (xx_ModelInstance* model_instance)
{
	/* Make sure that the Table2D initialization function can find the resource
	 * location for this FMU instance
	 */
	g_fmuResourceLocation = model_instance->resourceLocation;

	/* id_1\output = id_1\C; */
	xx_V[2] = xx_P[5];

	/* lf_1\AD_8bit\lsb = (lf_1\AD_8bit\maximum - lf_1\AD_8bit\minimum) / (exp2 (lf_1\AD_8bit\bits) - 1); */
	xx_V[7] = (xx_P[8] - xx_P[7]) / (XXExponent2 (xx_P[6]) - 1.0);

	/* lf_1\AD_8bit\noise_value = (2 ^ noise_level) * lf_1\AD_8bit\lsb; */
	xx_V[9] = (XXPower (2.0, xx_P[4])) * xx_V[7];

	/* lf_1\AD_8bit\half_lsb = lf_1\AD_8bit\lsb / 2; */
	xx_V[8] = xx_V[7] / 2.0;

	/* lf_1\id = trunc (id_1\output); */
	xx_V[20] =  ((XXInteger) (xx_V[2]));

	/* lf_1\calculate_sensor_position\id = trunc (lf_1\id); */
	xx_V[14] =  ((XXInteger) (xx_V[20]));

}

/* This function calculates the input equations of the model.
 * These equations are dynamic equations that must not change
 * in calls from the integration method (like random and delay).
 */
void XXCalculateInput (xx_ModelInstance* model_instance)
{
	/* Make sure that the Table2D initialization function can find the resource
	 * location for this FMU instance
	 */
	g_fmuResourceLocation = model_instance->resourceLocation;


}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void XXCalculateDynamic (xx_ModelInstance* model_instance)
{
	/* Make sure that the Table2D initialization function can find the resource
	 * location for this FMU instance
	 */
	g_fmuResourceLocation = model_instance->resourceLocation;

	/* Mux\robot_theta = robot_theta; */
	xx_V[46] = xx_V[54];

	/* Mux\robot_x = robot_x; */
	xx_V[43] = xx_V[55];

	/* Mux\robot_y = robot_y; */
	xx_V[44] = xx_V[56];

	/* Mux\robot_z = robot_z; */
	xx_V[45] = xx_V[57];

	/* Mux\output = [Mux\robot_x; Mux\robot_y; Mux\robot_z; Mux\robot_theta]; */
	xx_M[4].mat[0] = xx_V[43];
	xx_M[4].mat[1] = xx_V[44];
	xx_M[4].mat[2] = xx_V[45];
	xx_M[4].mat[3] = xx_V[46];

	/* lf_1\percentageTo8BitValue\output = lf_1\percentageTo8BitValue\K * lf_1\response_delay\Integrate\output; */
	xx_V[17] = xx_P[12] * xx_s[0];

	/* lf_1\AD_8bit\hold_signal = lf_1\percentageTo8BitValue\output + (lf_1\AD_8bit\noise_value * gauss (1)); */
	xx_V[4] = xx_V[17] + (xx_V[9] * XXRandom (1.0));

	/* lf_1\AD_8bit\windowed_signal = (if lf_1\AD_8bit\hold_signal <= lf_1\AD_8bit\minimum then lf_1\AD_8bit\minimum + lf_1\AD_8bit\half_lsb else (if lf_1\AD_8bit\hold_signal >= lf_1\AD_8bit\maximum then lf_1\AD_8bit\maximum - lf_1\AD_8bit\half_lsb else lf_1\AD_8bit\hold_signal end) end); */
	xx_V[5] = ((xx_V[4] <= xx_P[7]) ? 
		/* lf_1\AD_8bit\minimum + lf_1\AD_8bit\half_lsb */
		(xx_P[7] + xx_V[8])
	:
		/* (if lf_1\AD_8bit\hold_signal >= lf_1\AD_8bit\maximum then lf_1\AD_8bit\maximum - lf_1\AD_8bit\half_lsb else lf_1\AD_8bit\hold_signal end) */
		((xx_V[4] >= xx_P[8]) ? 
			/* lf_1\AD_8bit\maximum - lf_1\AD_8bit\half_lsb */
			(xx_P[8] - xx_V[8])
		:
			/* lf_1\AD_8bit\hold_signal */
			xx_V[4]
		)
	);

	/* lf_1\AD_8bit\quantisized_signal = (if lf_1\AD_8bit\windowed_signal < 0.0 then lf_1\AD_8bit\windowed_signal - lf_1\AD_8bit\half_lsb else lf_1\AD_8bit\windowed_signal + lf_1\AD_8bit\half_lsb end); */
	xx_V[6] = ((xx_V[5] < 0.0) ? 
		/* lf_1\AD_8bit\windowed_signal - lf_1\AD_8bit\half_lsb */
		(xx_V[5] - xx_V[8])
	:
		/* lf_1\AD_8bit\windowed_signal + lf_1\AD_8bit\half_lsb */
		(xx_V[5] + xx_V[8])
	);

	/* lf_1\AD_8bit\output = lf_1\AD_8bit\quantisized_signal - (lf_1\AD_8bit\quantisized_signal mod lf_1\AD_8bit\lsb); */
	xx_V[3] = xx_V[6] - (XXIntegerModulo (xx_V[6], xx_V[7]));

	/* lf_1\calculate_sensor_position\rotated_x = (lf_position_x * cos (Mux\output[4])) - (lf_position_y * sin (Mux\output[4])); */
	xx_V[15] = (xx_P[0] * cos (xx_M[4].mat[3])) - (xx_P[1] * sin (xx_M[4].mat[3]));

	/* lf_1\calculate_sensor_position\rotated_y = (lf_position_x * sin (Mux\output[4])) + (lf_position_y * cos (Mux\output[4])); */
	xx_V[16] = (xx_P[0] * sin (xx_M[4].mat[3])) + (xx_P[1] * cos (xx_M[4].mat[3]));

	/* lf_1\calculate_sensor_position\sensor_position[1] = Mux\output[1] + lf_1\calculate_sensor_position\rotated_x; */
	xx_M[0].mat[0] = xx_M[4].mat[0] + xx_V[15];

	/* lf_1\calculate_sensor_position\sensor_position[2] = Mux\output[2] + lf_1\calculate_sensor_position\rotated_y; */
	xx_M[0].mat[1] = xx_M[4].mat[1] + xx_V[16];

	/* [Demux4\output1; Demux4\output2] = lf_1\calculate_sensor_position\sensor_position; */
	xx_V[0] = xx_M[0].mat[0];
	xx_V[1] = xx_M[0].mat[1];

	/* for map\x1 = 1 to map\sample_matrix_size */
	for (xx_V[39] = 1.0; xx_V[39] <= xx_P[19]; xx_V[39]++)
	{
		/* for map\y1 = 1 to map\sample_matrix_size */
		for (xx_V[40] = 1.0; xx_V[40] <= xx_P[19]; xx_V[40]++)
		{
			/* map\input1[1] = map\id; */
			xx_M[1].mat[0] = xx_V[22];

			/* map\input1[2] = lf_1\calculate_sensor_position\sensor_position[2] + map\sample_offsets[map\x1]; */
			xx_M[1].mat[1] = xx_M[0].mat[1] + xx_M[2].mat[(XXInteger) (xx_V[39]) - 1];

			/* map\input1[3] = lf_1\calculate_sensor_position\sensor_position[1] + map\sample_offsets[map\y1]; */
			xx_M[1].mat[2] = xx_M[0].mat[0] + xx_M[2].mat[(XXInteger) (xx_V[40]) - 1];

			/* map\retval = dll (map\dll_name, map\function_name, map\input1); */
			Table2D_TableRead (xx_M[1].mat, 3, &xx_V[42], 1, xx_major);

			/* map\sample_matrix1[map\x1,map\y1] = map\retval; */
			xx_M[3].mat[(XXInteger)(xx_V[39] - 1) * 3 + (XXInteger)(xx_V[40] - 1)] = xx_V[42];
		}
	}

	/* map\sensor_value1 = msum (map\sample_matrix1) / map\sample_matrix_size ^ 2; */
	XXMatrixSum (xx_M[5].mat, &xx_M[3]);
	/* map\sensor_value1 = msum (map\sample_matrix1) / map\sample_matrix_size ^ 2; */
	xx_V[21] = xx_M[5].mat[0] / (xx_P[19] * xx_P[19]);

	/* lf_1\raw_to_reflectivity\reflectivity = lf_1\raw_to_reflectivity\hi_output - (((lf_1\raw_to_reflectivity\hi_input - map\sensor_value1) / (lf_1\raw_to_reflectivity\hi_input - lf_1\raw_to_reflectivity\lo_input)) * (lf_1\raw_to_reflectivity\hi_output - lf_1\raw_to_reflectivity\lo_output)); */
	xx_V[18] = xx_P[16] - (((xx_P[14] - xx_V[21]) / (xx_P[14] - xx_P[13])) * (xx_P[16] - xx_P[15]));

	/* lf_1\ambient_light\reflected_power = (lf_1\ambient_light\led_power + ambient_light) * lf_1\raw_to_reflectivity\reflectivity; */
	xx_V[11] = (xx_P[9] + xx_P[3]) * xx_V[18];

	/* if lf_1\ambient_light\reflected_power <= lf_1\ambient_light\rx_power_off */
	if (xx_V[11] <= xx_P[10])
	{
		/* lf_1\ambient_light\output = 0; */
		xx_V[10] = 0.0;
	}
	else
	{
		/* if lf_1\ambient_light\reflected_power >= lf_1\ambient_light\rx_power_on */
		if (xx_V[11] >= xx_P[11])
		{
			/* lf_1\ambient_light\output = 1; */
			xx_V[10] = 1.0;
		}
		else
		{
			/* lf_1\ambient_light\output = (lf_1\ambient_light\reflected_power - lf_1\ambient_light\rx_power_off) / (lf_1\ambient_light\rx_power_on - lf_1\ambient_light\rx_power_off); */
			xx_V[10] = (xx_V[11] - xx_P[10]) / (xx_P[11] - xx_P[10]);
		}
	}

	/* lf_1\response_delay\PlusMinus\output = lf_1\ambient_light\output - lf_1\response_delay\Integrate\output; */
	xx_V[19] = xx_V[10] - xx_s[0];

	/* lf_1\response_delay\Integrate\input = lf_1\response_delay\Gain\sensor_response_factor * lf_1\response_delay\PlusMinus\output; */
	xx_R[0] = xx_P[17] * xx_V[19];


	/* increment the step counter */
	model_instance->steps++;
}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void XXCalculateOutput (xx_ModelInstance* model_instance)
{
	/* Make sure that the Table2D initialization function can find the resource
	 * location for this FMU instance
	 */
	g_fmuResourceLocation = model_instance->resourceLocation;

	/* lf_1_sensor_reading = lf_1\AD_8bit\output; */
	xx_V[53] = xx_V[3];

	/* lf_1_sensor_position_x = Demux4\output1; */
	xx_V[51] = xx_V[0];

	/* lf_1_sensor_position_y = Demux4\output2; */
	xx_V[52] = xx_V[1];

}

/* This function calculates the final equations of the model.
 * These equations are calculated after all the calculations
 * are performed
 */
void XXCalculateFinal (xx_ModelInstance* model_instance)
{
	/* Make sure that the Table2D initialization function can find the resource
	 * location for this FMU instance
	 */
	g_fmuResourceLocation = model_instance->resourceLocation;

	Table2D_Terminate ();

}

/* this method is called after all calculations are performed */
void XXModelTerminate(xx_ModelInstance* model_instance)
{
}


